<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Druid</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">2.</strong> Set up Druid</a></li><li class="chapter-item expanded "><a href="get_started.html"><strong aria-hidden="true">3.</strong> Get started with Druid</a></li><li class="chapter-item expanded "><a href="data.html"><strong aria-hidden="true">4.</strong> Data trait</a></li><li class="chapter-item expanded "><a href="widget.html"><strong aria-hidden="true">5.</strong> Widget trait</a></li><li class="chapter-item expanded "><a href="lens.html"><strong aria-hidden="true">6.</strong> Lens trait</a></li><li class="chapter-item expanded "><a href="env.html"><strong aria-hidden="true">7.</strong> Env</a></li><li class="chapter-item expanded "><a href="resolution_independence.html"><strong aria-hidden="true">8.</strong> Resolution independence</a></li><li class="chapter-item expanded "><a href="localization.html"><strong aria-hidden="true">9.</strong> Localization (TODO)</a></li><li class="chapter-item expanded "><a href="command.html"><strong aria-hidden="true">10.</strong> Command (TODO)</a></li><li class="chapter-item expanded "><a href="custom_widgets.html"><strong aria-hidden="true">11.</strong> Widgets in depth (TODO)</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="more_information.html"><strong aria-hidden="true">12.</strong> More information</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Druid</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#druid" id="druid">Druid</a></h1>
<p>Druid is a framework for building simple graphical applications.</p>
<p>Druid is composed of a number of related projects. <a href="https://docs.rs/druid-shell"><code>druid-shell</code></a> is a
low-level library that provides a common abstraction for interacting with the
current OS &amp; window manager. <a href="https://docs.rs/piet"><code>piet</code></a> is an abstraction for doing 2D graphics;
<a href="https://docs.rs/kurbo"><code>kurbo</code></a> is a library for 2D geometry; and <a href="https://docs.rs/druid"><code>druid</code></a> itself is an opinionated set of
high-level APIs for building cross-platform desktop applications.</p>
<p>Druid is <em>data oriented</em>. It shares many ideas (and is directly inspired by)
contemporary declarative UI frameworks such as <a href="https://flutter.dev">Flutter</a>, <a href="https://developer.android.com/jetpack/compose">Jetpack Compose</a>,
and <a href="https://developer.apple.com/documentation/swiftui">SwiftUI</a>, while also attempting to be conceptually simple and largely
<em>non-magical</em>. A programmer familiar with Rust should be able to understand how
Druid works without special difficulty.</p>
<h2><a class="header" href="#goals-and-status" id="goals-and-status">Goals and Status</a></h2>
<p>The current goal of Druid is to make it easy to write a program in Rust that
can present a GUI and accept user input. Running your program should be as
simple as <code>cargo run</code>.</p>
<h2><a class="header" href="#key-concepts" id="key-concepts">Key Concepts</a></h2>
<ul>
<li><strong><a href="./data.html">the <code>Data</code> trait</a></strong>: How you represent your application model.</li>
<li><strong><a href="./widget.html">the <code>Widget</code> trait</a></strong>: How you represent your UI.</li>
<li><strong><a href="./lens.html">the <code>Lens</code> trait</a></strong>: How you associate parts of your model with parts of
your UI.</li>
</ul>
<h1><a class="header" href="#set-up-druid" id="set-up-druid">Set up Druid</a></h1>
<p>This tutorial assumes basic familliarity with Rust and a working setup with the basic tooling like
Rustup and Cargo. This tutorial will use stable Rust (v1.39.0 at the time of writing) and the latest
released version of Druid.</p>
<p>This tutorial will first walk you through setting up the dependencies for developing a Druid
application, then it will show you how to set up a basic application, build it and run it.</p>
<h2><a class="header" href="#setting-up-druid-dependencies" id="setting-up-druid-dependencies">Setting up Druid dependencies</a></h2>
<p>In addition to including the <code>druid</code> library in your project</p>
<h3><a class="header" href="#linux" id="linux">Linux</a></h3>
<p>On Linux, Druid requires gtk+3.</p>
<p>On Ubuntu this can be installed with</p>
<pre><code class="language-no_compile">sudo apt-get install libgtk-3-dev
</code></pre>
<p>On Fedora</p>
<pre><code class="language-no_compile">sudo dnf install gtk3-devel glib2-devel
</code></pre>
<p>See <a href="https://www.gtk.org/docs/installations/linux/">GTK installation page</a> for more installation instructions.</p>
<h3><a class="header" href="#openbsd" id="openbsd">OpenBSD</a></h3>
<p>On OpenBSD, Druid requires gtk+3;  install from packages:</p>
<pre><code class="language-no_compile">pkg_add gtk+3
</code></pre>
<h2><a class="header" href="#starting-a-project" id="starting-a-project">Starting a project</a></h2>
<p>Starting a project is as easy as creating an empty application with</p>
<pre><code class="language-no_compile">cargo new my-application
</code></pre>
<p>and adding the druid dependency to your Cargo.toml</p>
<pre><code class="language-no_compile">[dependencies]
druid = &quot;0.7.0&quot;
// or to be on the bleeding edge:
druid = { git = &quot;https://github.com/linebender/druid.git&quot; }
</code></pre>
<p>This book is written against the latest code on git, so some examples may not work with <code>0.7.0</code>.</p>
<h1><a class="header" href="#get-started-with-druid" id="get-started-with-druid">Get started with Druid</a></h1>
<p><em>this is outdated, and should be replaced with a walkthrough of getting a simple
app built and running</em>.</p>
<p>This chapter will walk you through setting up a simple Druid application from start to finish.</p>
<h2><a class="header" href="#set-up-a-druid-project" id="set-up-a-druid-project">Set up a Druid project</a></h2>
<p>Setting up a project is a simple as creating a new Rust project;</p>
<pre><code class="language-bash">&gt; cargo new druid-example
</code></pre>
<p>And then adding Druid as a dependency to Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
druid = { git = &quot;https://github.com/linebender/druid.git&quot; }
</code></pre>
<p>To show a minimal window with a label replace <code>main.rs</code> with this;</p>
<pre><code class="language-rust noplaypen">use druid::{AppLauncher, WindowDesc, Widget, PlatformError};
use druid::widget::Label;

fn build_ui() -&gt; impl Widget&lt;()&gt; {
    Label::new(&quot;Hello world&quot;)
}

fn main() -&gt; Result&lt;(), PlatformError&gt; {
    AppLauncher::with_window(WindowDesc::new(build_ui())).launch(())?;
    Ok(())
}
</code></pre>
<p>In our main function we create an <code>AppLauncher</code>, pass it a <code>WindowDesc</code>, and launch it. We use <code>build_ui</code> to create a tree of widgets to pass to our <code>WindowDesc</code>. For now this tree consists of one simple label widget.</p>
<p>This is a very simple example application and it's missing some important pieces. We will add these in the coming few paragraphs.</p>
<h2><a class="header" href="#draw-more-widgets" id="draw-more-widgets">Draw more widgets</a></h2>
<p>The first thing we could do to make our example application more interesting is to draw more than one widget. Unfortunately <code>WindowDesc::new</code> expects a function that returns only one Widget. We also need a way to tell Druid how to lay-out our widgets.
We solve both these problems by passing in a widget-tree with one single widget at the top. Widgets can have children and widgets higher up in the tree know how to lay-out their children. That way we describe a window as a widget-tree with layout containers as the branches and widgets as the leaves. Our <code>build_ui</code> function is then responsible for building this widget tree.</p>
<p>To see how this works we will divide our window in four. We'll have two rows and two columns with a single label in each of the quadrants. We can lay-out our labels using the <code>Flex</code> widget.</p>
<pre><code class="language-rust noplaypen">fn build_ui() -&gt; impl Widget&lt;()&gt; {
    Flex::row()
        .with_flex_child(
            Flex::column()
                .with_flex_child(Label::new(&quot;top left&quot;), 1.0)
                .with_flex_child(Label::new(&quot;bottom left&quot;), 1.0),
            1.0)
        .with_flex_child(
            Flex::column()
                .with_flex_child(Label::new(&quot;top right&quot;), 1.0)
                .with_flex_child(Label::new(&quot;bottom right&quot;), 1.0),
            1.0)
}
</code></pre>
<p>This looks nice but the labels on the left are drawn right against the window edge, so we needs some padding. Lets say we also want to center the two bottom labels. Unlike many other UI frameworks, widgets in Druid don't have padding or alignment properties themselves. Widgets are kept as simple as possible.</p>
<p>Features like padding or alignment are implemented in separate widgets. To add padding you simply wrap the labels in a <code>Padding</code> widget. Centering widgets is done using the <code>Align</code> widget set to <code>centered</code>.</p>
<pre><code class="language-rust noplaypen">fn build_ui() -&gt; impl Widget&lt;()&gt; {
    Padding::new(
        10.0,
        Flex::row()
            .with_flex_child(
                Flex::column()
                    .with_flex_child(Label::new(&quot;top left&quot;), 1.0)
                    .with_flex_child(Align::centered(Label::new(&quot;bottom left&quot;)), 1.0),
                1.0)
            .with_flex_child(
                Flex::column()
                    .with_flex_child(Label::new(&quot;top right&quot;), 1.0)
                    .with_flex_child(Align::centered(Label::new(&quot;bottom right&quot;)), 1.0),
                1.0))
}
</code></pre>
<p>Do not forget to import the new widgets;</p>
<pre><code class="language-rust noplaypen">use druid::widget::{Label, Flex, Padding, Align};
</code></pre>
<h2><a class="header" href="#application-state" id="application-state">Application state</a></h2>
<p>We can display a window and draw and position widgets in it. Now it's time to find out how we can tie these widgets to
the rest of our application. First lets see how we can display information from our application in the user interface.
For this we need to define what our application's state looks like.</p>
<p>...</p>
<h2><a class="header" href="#handle-user-input" id="handle-user-input">Handle user input</a></h2>
<p>...</p>
<h2><a class="header" href="#putting-it-all-together" id="putting-it-all-together">Putting it all together</a></h2>
<p>...</p>
<h1><a class="header" href="#model-data-and-the-data-trait" id="model-data-and-the-data-trait">Model data and the <code>Data</code> trait</a></h1>
<p>The heart of a Druid application is your application model. Your model drives
your UI. When you mutate your model, Druid compares the old and new version,
and propagates the change to the components ('widgets') of your application that
are affected by the change.</p>
<p>For this to work, your model must implement the <code>Clone</code> and <code>Data</code> traits. It
is important that your model be cheap to clone; we encourage the use of
reference counted pointers to allow cheap cloning of more expensive types. <code>Arc</code>
and <code>Rc</code> have blanket <code>Data</code> impls, so if you have a type that does not
implement <code>Data</code>, you can always just wrap it in one of those smart pointers.</p>
<p>The <code>Data</code> trait has a single method:</p>
<pre><code class="language-rust no_run noplaypen">    /// Determine whether two values are the same.
    ///
    /// This is intended to always be a fast operation. If it returns
    /// `true`, the two values *must* be equal, but two equal values
    /// need not be considered the same here, as will often be the
    /// case when two copies are separately allocated.
    ///
    /// Note that &quot;equal&quot; above has a slightly different meaning than
    /// `PartialEq`, for example two floating point NaN values should
    /// be considered equal when they have the same bit representation.
    fn same(&amp;self, other: &amp;Self) -&gt; bool;
</code></pre>
<h4><a class="header" href="#derive" id="derive">Derive</a></h4>
<p><code>Data</code> can be derived. This is recursive; it requires <code>Data</code> to be implemented
for all members. For 'C style' enums (enums where no variant has any fields)
this also requires an implementation of <code>PartialEq</code>. <code>Data</code> is implemented for
a number of <code>std</code> types, including all primitive types, <code>String</code>, <code>Arc</code>, <code>Rc</code>,
as well as <code>Option</code>, <code>Result</code>, and various tuples whose members implement
<code>Data</code>.</p>
<p>Here is an example of using <code>Data</code> to implement a simple data model.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use druid::Data;
use std::sync::Arc;

#[derive(Clone, Data)]
/// The main model for a todo list application.
struct TodoList {
    items: Arc&lt;Vec&lt;TodoItem&gt;&gt;,
}

#[derive(Clone, Data)]
/// A single todo item.
struct TodoItem {
    category: Category,
    title: String,
    note: Option&lt;String&gt;,
    completed: bool,

    // `Data` is implemented for any `Arc`.
    due_date: Option&lt;Arc&lt;DateTime&gt;&gt;,

    // You can specify a custom comparison fn
    // (anything with the signature (&amp;T, &amp;T) -&gt; bool).
    #[data(same_fn = &quot;PartialEq::eq&quot;)]
    added_date: DateTime,

    // You can specify that a field should
    // be skipped when computing same-ness
    #[data(ignore)]
    debug_timestamp: usize,
}

#[derive(Clone, Data, PartialEq)]
/// The three types of tasks in the world.
enum Category {
    Work,
    Play,
    Revolution,
}
<span class="boring">}
</span></code></pre></pre>
<h4><a class="header" href="#collections" id="collections">Collections</a></h4>
<p><code>Data</code> is expected to be cheap to clone and cheap to compare, which can cause
issues with collection types. For this reason, <code>Data</code> is not implemented for
<code>std</code> types like <code>Vec</code> or <code>HashMap</code>. This is not a huge issue, however; you can
always put these types inside an <code>Rc</code> or an <code>Arc</code>, or if you're dealing with
larger collections you can build Druid with the <code>im</code> feature, which brings in
the [<code>im crate</code>], and adds a <code>Data</code> impl for the collections there. The <a href="https://docs.rs/im"><code>im</code>
crate</a> is a collection of immutable data structures that act a lot like the <code>std</code>
collections, but can be cloned efficiently.</p>
<h1><a class="header" href="#widgets-and-the-widget-trait" id="widgets-and-the-widget-trait">Widgets and the <code>Widget</code> trait</a></h1>
<p>The <code>Widget</code> trait represents components of your UI. Druid includes a set of
built-in widgets, and you can also write your own. You combine the built-in
and custom widgets to create a <em>widget tree</em>; you will start with some single
<em>root widget</em>, which will (generally) have children, which may themselves have
children, and so on. <code>Widget</code> has a generic parameter <code>T</code> that represents
the <a href="./data.html"><code>Data</code></a> handled by that widget. Some widgets (such as layout widgets)
may be entirely agnostic about what sort of <code>Data</code> they encounter, while other
widgets (such as a slider) may expect a single type (such as <code>f64</code>).</p>
<blockquote>
<p><strong>Note</strong>: For more information on how different parts of your <a href="./data.html"><code>Data</code></a> are exposed
to different widgets, see <a href="./lens.html"><code>Lens</code></a>.</p>
</blockquote>
<p>At a high level, Druid works like this:</p>
<ul>
<li><strong>event</strong>: an <code>Event</code> arrives from the operating system, such as a key press,
a mouse movement, or a timer firing. This event is delivered to your root
widget's <code>event</code> method. This method is provided <strong>mutable</strong> access to your
application model; this is the only place where your model can change. Depending
on the type of <code>Event</code> and the implementation of your <code>event</code> method, this
event is then delivered recursively down the tree until it is handled.</li>
<li><strong>update</strong>: After this call returns, the framework checks to see if the data was mutated.
If so, it calls your root widget's <code>update</code> method, passing in both the new
data as well as the previous data. Your widget can then update any internal
state (data that the widget uses that is not part of the application model,
such as appearance data) and can request a <code>layout</code> or a <code>paint</code> call if
its appearance is no longer valid.</li>
<li>After <code>update</code> returns, the framework checks to see if any widgets in a
given window have indicated that they need layout or paint. If so, the
framework will call the following methods:</li>
<li><strong>layout</strong>: This is where the framework determines where to position each
widget on the screen. Druid uses a layout system heavily inspired by Flutter's
<a href="https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html">box layout model</a>: widgets are passed constraints, in the form of a minimum
and a maximum allowed size, and they return a size in that range.</li>
<li><strong>paint</strong>: After <code>layout</code>, the framework calls your widget's <code>paint</code> method.
This is where your widget draws itself, using a familiar imperative 2D graphics
API.</li>
<li>In addition to these four methods, there is also <strong>lifecycle</strong>, which is
called in response to various changes to framework state; it is not called
predictably during event handling, but only when extra information (such
as if a widget has gained focus) happens as a consequence of other events.</li>
</ul>
<p>For more information on implementing these methods, see <a href="./custom_widgets.html">Creating custom
widgets</a>.</p>
<h2><a class="header" href="#modularity-and-composition" id="modularity-and-composition">Modularity and composition</a></h2>
<p>Widgets are intended to be modular and composable, not monolithic. For instance,
widgets generally do not control their own alignment or padding; if you have
a label, and you would like it to have 8dp of horizontal padding and 4dp of
vertical padding, you can just do,</p>
<pre><code class="language-rust noplaypen">use druid::widget::{Label, Padding};

fn padded_label() {
    let label: Label&lt;()&gt; = Label::new(&quot;Humour me&quot;);
    let padded = Padding::new((4.0, 8.0), label);
}
</code></pre>
<p>to force the label to be center-aligned if it is given extra space you can write,</p>
<pre><code class="language-rust noplaypen">use druid::widget::Align;

fn align_center() {
    let label: Label&lt;()&gt; = Label::new(&quot;Center me&quot;);
    let centered = Align::centered(label);
}
</code></pre>
<h2><a class="header" href="#builder-methods-and-widgetext" id="builder-methods-and-widgetext">Builder methods and <code>WidgetExt</code></a></h2>
<p>Widgets are generally constructed using builder-style methods. Unlike the normal
<a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">builder pattern</a>, we generally do not separate the type that is
built from the builder type; instead the builder methods are on the widget
itself.</p>
<pre><code class="language-rust noplaypen">use druid::widget::Stepper;

fn steppers() {
    // A Stepper with default parameters
    let stepper1 = Stepper::new();

    // A Stepper that operates over a custom range
    let stepper2 = Stepper::new().with_range(10.0, 50.0);

    // A Stepper with a custom range *and* a custom step size, that
    // wraps around past its min and max values:
    let stepper3 = Stepper::new()
        .with_range(10.0, 50.0)
        .with_step(2.5)
        .with_wraparound(true);
}
</code></pre>
<p>Additionally, there are a large number of helper methods available on all
widgets, as part of the <code>WidgetExt</code> trait. These builder-style methods take one
widget and wrap it in another. The following two functions produce the same
output:</p>
<p><strong>Explicit</strong>:</p>
<pre><code class="language-rust noplaypen">use druid::widget::{Align, Padding, Stepper};

fn padded_stepper() {
    let stepper = Stepper::new().with_range(10.0, 50.0);
    let padding = Padding::new(8.0, stepper);
    let padded_and_center_aligned_stepper = Align::centered(padding);
}
</code></pre>
<p><strong>WidgetExt</strong>:</p>
<pre><code class="language-rust noplaypen">use druid::widget::{Stepper, WidgetExt};

fn padded_stepper() {
    let padded_and_center_aligned_stepper =
        Stepper::new().with_range(10.0, 50.0).padding(8.0).center();
}
</code></pre>
<p>These builder-style methods also exist on containers. For instance, to create
a stack of three labels, you can do:</p>
<pre><code class="language-rust noplaypen">use druid::widget::Flex;

fn flex_builder() -&gt; Flex&lt;()&gt; {
    Flex::column()
        .with_child(Label::new(&quot;Number One&quot;))
        .with_child(Label::new(&quot;Number Two&quot;))
        .with_child(Label::new(&quot;Some Other Number&quot;))
}
</code></pre>
<h1><a class="header" href="#lenses-and-the-lens-trait" id="lenses-and-the-lens-trait">Lenses and the <code>Lens</code> trait</a></h1>
<p>One of the key abstractions in <code>druid</code> along with <code>Data</code> is the <code>Lens</code> trait. This page explains what they are, and then how to use them. <code>Lens</code>es may seem complicated at first, but they are also very powerful, allowing you to write code that is reusable, concise, and understandable (once you understand <code>Lens</code>es themselves).</p>
<h2><a class="header" href="#fundamentals-definition-and-implementation" id="fundamentals-definition-and-implementation">Fundamentals: Definition and Implementation</a></h2>
<p>Like Rust itself, lenses are one of those things that require effort up front to learn, but are very fun and effective to use once you understand them. This section represents the effort part of the equation. I promise if you stick with it you will reap the rewards.</p>
<h3><a class="header" href="#definition" id="definition">Definition</a></h3>
<p>Let's start with the definition of a <code>Lens</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Lens&lt;T, U&gt; {
    fn with&lt;F: FnOnce(&amp;U)&gt;(&amp;self, data: &amp;T, f: F);

    fn with_mut&lt;F: FnOnce(&amp;mut U)&gt;(&amp;self, data: &amp;mut T, f: F);
}
<span class="boring">}
</span></code></pre></pre>
<p>I've copied this definition from the <code>druid</code> source code, but then simplified it a little, by removing the return types, as they are not fundamental to the way lenses work.</p>
<p>The first thing to notice is the generics on the <code>Lens</code> itself. There are 3 types involve in the lens: the lens itself, <code>T</code> and <code>U</code>. The two type parameters represent the mismatch that lenses solve: we have a function that operates on <code>U</code>, and an object of type <code>T</code>, so we need to transform <code>T</code> into <code>U</code> somehow.</p>
<h3><a class="header" href="#implementation" id="implementation">Implementation</a></h3>
<p>Time for an example. Let's implement &amp; use <code>Lens</code> manually so we can see what's going on.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Container {
    inner: String,
    another: String,
}

// Here the lens doesn't have any data, but there are cases where
// it might, for example it might contain an index into a collection.
struct InnerLens;

// Our lens will apply functions that operate on a `String` to a `Container`.
impl Lens&lt;Container, String&gt; for InnerLens {
    fn with&lt;F: FnOnce(&amp;String)&gt;(&amp;self, data: &amp;Container, f: F) {
        f(&amp;data.inner);
    }

    fn with_mut&lt;F: FnOnce(&amp;mut String)&gt;(&amp;self, data: &amp;mut Container, f: F) {
        f(&amp;mut data.inner);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is a very simple case. All we need to do is project the function onto the field. Notice that this isn't the only valid lens from <code>Container</code> to <code>String</code> we could have made - we could also project from <code>Container</code> to <code>another</code>. We made the choice how to transform <code>Container</code> into <code>String</code> when we implemented <code>Lens</code>.</p>
<blockquote>
<p>Side note: Actually we could project on to any string we have access to, including something in a global mutex, or a string that we create and discard in the lens. Lenses made like this are usually not what you want.</p>
</blockquote>
<p>You'll also notice that both methods take an immutable reference to <code>self</code>, even the <code>mut</code> variant. The lense itself should be thought of as a fixed thing that knows how to do the mapping. In the above case it contains no data, and will most likely not even be present in the final compiled/optimized code.</p>
<p>Now for a slightly more involved example</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Container2 {
    first_name: String,
    last_name: String,
    age: u16, // in the future maybe people will live past 256?
}

struct Name {
    first: String,
    last: String,
}

struct NameLens;

impl Lens&lt;Container2, Name&gt; for NameLens {
    fn with&lt;F: FnOnce(&amp;Name)&gt;(&amp;self, data: &amp;Container2, f: F) {
        let first = data.first_name.clone();
        let last = data.last_name.clone();
        f(&amp;Name { first, last });
    }

    fn with_mut&lt;F: FnOnce(&amp;mut Name)&gt;(&amp;self, data: &amp;mut Container2, f: F) {
        let first = data.first_name.clone();
        let last = data.last_name.clone();
        let mut name = Name { first, last };
        f(&amp;mut name);
        data.first_name = name.first;
        data.last_name = name.last;
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Side note: if you try doing this with <code>struct Name&lt;'a&gt; { first: &amp;'a String, ...</code>, you'll find that it's not possible to be generic over the mutability of the fields in <code>Name</code>, so we can't make the <code>Name</code> struct borrow the data both mutably and immutably. Even if we could in this case, things quickly get very complicated. Also, sometimes <code>Widget</code>s need to keep a copy of the data around for use internally. For now the accepted best practice is to make <code>Clone</code>ing cheap and use that.</p>
</blockquote>
<p>Now as I'm sure you've realised, the above is very inefficient. Given that we will be traversing our data very often, we need it to be cheap. (This wasn't a problem before, because when we don't need to build the inner type, we can just use references. It also wouldn't be a problem if our data was cheap to copy/clone, for example any of the primitive number types <code>u8</code>, ... <code>f64</code>.) Luckily, this is exactly the kind of thing that rust excels at. Let's rewrite the above example to be fast!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Container2 {
    first_name: Rc&lt;String&gt;,
    last_name: Rc&lt;String&gt;,
    age: u16,
}

struct Name {
    first: Rc&lt;String&gt;,
    last: Rc&lt;String&gt;,
}

struct NameLens;

impl Lens&lt;Container2, Name&gt; for NameLens {
    // .. identical to previous example
}
<span class="boring">}
</span></code></pre></pre>
<p>As you'll see, we've introduced <code>Rc</code>: the reference-counted pointer. You will see this and its multithreaded cousin <code>Arc</code> used pervasively in the examples. Now, the only time we actually have to copy memory is when <code>Rc::make_mut</code> is called in the <code>f</code> in <code>with_mut</code>. This means that in the case where nothing changes, all we will be doing is incrementing and decrementing reference counts. Moreover, we give the compiler the opportunity to inline <code>f</code> and <code>with</code>/<code>with_mut</code>, making this abstraction potentially zero-cost (disclaimer: I haven't actually studied the produced assembly to validate this claim).</p>
<p>The trade-off is that we introduce more complexity into the <code>Name</code> type: to make changes to the data we have to use <code>Rc::make_mut</code> to get mutable access to the <code>String</code>. (The code in the lens will ensure that the newer copy of the <code>Rc</code>d data is saved to the outer type.) This means the writing fast druid code requires knowledge of the Rust pointer types (<code>Rc</code>/<code>Arc</code>, and also potentially <code>RefCell</code>/<code>Mutex</code>).</p>
<p>We can actually do even better than this. Suppose that we are working on a vector of data rather than a string. We can import the <code>im</code> crate to get collections that use <em>structural sharing</em>, meaning that even when the vector is mutated, we only <em>Clone</em> what we need to. Because <code>im</code> is so useful, it is included in <code>druid</code> (behind the <code>im</code> feature).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Container2 {
    // Pretend that it's the 1980s and we store only ASCII names.
    first_name: im::Vector&lt;u8&gt;,
    last_name: im::Vector&lt;u8&gt;,
    age: u16,
}

struct Name {
    first: im::Vector&lt;u8&gt;,
    last: im::Vector&lt;u8&gt;,
}

struct NameLens;

impl Lens&lt;Container2, Name&gt; for NameLens {
    // .. identical to previous example
}
<span class="boring">}
</span></code></pre></pre>
<p>Now in addition to almost free <code>Clone</code>s, we also have cheap incremental updates to the data itself. In the case of names, this isn't that important, but if the vector had <code>1_000_000_000</code> elements, we could still make changes in only <em>O(log(n))</em> time (in this case the difference between <code>1_000_000_000</code> and <code>30</code> - pretty big!).</p>
<p>Right, now you understand how <code>Lens</code>es work. Congratulations, you've done the hardest bit! If you get lost later on, read this section again, and eventually it will all make sense.</p>
<h3><a class="header" href="#bonus---the-actual-lens-definition" id="bonus---the-actual-lens-definition">Bonus - The actual <code>Lens</code> definition</a></h3>
<p>The actual definition of <code>Lens</code> in <code>druid</code> allows the user to return values from the lens. This isn't necessary for the core functioning of the lens, but it is useful. Also, because the types <code>T</code> and <code>U</code> always appear behind pointers (<code>&amp;</code> and <code>&amp;mut</code>), we can relax the <code>Sized</code> requirement that is applied by default, meaning we can implement <code>Lens</code> for types like <code>[T]</code> (slice) and <code>str</code>.</p>
<p>Here is the real definition for completeness:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Lens&lt;T: ?Sized, U: ?Sized&gt; {
    fn with&lt;V, F: FnOnce(&amp;U) -&gt; V&gt;(&amp;self, data: &amp;T, f: F) -&gt; V;

    fn with_mut&lt;V, F: FnOnce(&amp;mut U) -&gt; V&gt;(&amp;self, data: &amp;mut T, f: F) -&gt; V;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#lenses-in-druid" id="lenses-in-druid">Lenses in Druid</a></h2>
<p>Now on to the more fun bit: how we can use <code>Lens</code>es to get all those lovely qualities we talked about in the introduction. What you'll notice in this section is that we rarely have to build lenses ourself: we can often get what we want using the <code>Lens</code> proc macro, or through the functions in <code>LensExt</code>.</p>
<h3><a class="header" href="#deriving-lenses" id="deriving-lenses">Deriving lenses</a></h3>
<p>Let's go back to the first example we looked at, with one of the fields removed for simplicity:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Lens)]
struct Container {
    inner: u8,
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's look at the code that gets generated (I captured this using <code>cargo-expand</code>, then removed some unimportant bits).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod container_derived_lenses {
    #[allow(non_camel_case_types)]
    pub struct inner;
}
impl druid::Lens&lt;Container, u8&gt; for container_derived_lenses::inner {
    fn with&lt;V, F: FnOnce(&amp;u8) -&gt; V&gt;(&amp;self, data: &amp;Container, f: F) -&gt; V {
        f(&amp;data.inner)
    }
    fn with_mut&lt;V, F: FnOnce(&amp;mut u8) -&gt; V&gt;(&amp;self, data: &amp;mut Container, f: F) -&gt; V {
        f(&amp;mut data.inner)
    }
}
#[allow(non_upper_case_globals)]
impl Container {
    pub const inner: container_derived_lenses::inner = container_derived_lenses::inner;
}
<span class="boring">}
</span></code></pre></pre>
<p>The macro has created a new module with a long name, put a struct in it that breaks the type naming convention, implemented <code>Lens</code> on the type, and then put a constant in an <code>impl</code> block for your data type with the same name. The upshot is that we can do <code>StructName::field_name</code> and get a lens from the struct to its field.</p>
<blockquote>
<p>Side note: Doing this makes using the lenses very simple (you just do <code>StructName::field_name</code>), but it can be a bit confusing, because of breaking the naming conventions. This is the reason I've included the expanded code in the page.</p>
</blockquote>
<h3><a class="header" href="#composing-lenses" id="composing-lenses">Composing lenses</a></h3>
<p>If I told you that the concept of lenses comes from Haskell (the functional megolith), I'm sure you won't be surprised when I also tell you that they really excel when it comes to composition. Let's say we have an outer struct that contains an inner struct, with the inner struct containing a <code>String</code>. Now let's say we want to tell a label widget to display the string as text in a label. We could write a lens from the outer struct to the string, which would look something like <code>f(&amp;outer.inner.text)</code>, but actually we don't need to do this: we can use the <code>then</code> combinator. The full example is below</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Lens)]
struct Outer {
    inner: Inner,
}

#[derive(Lens)]
struct Inner {
    text: String
}

// `composed_lens` will contain a lens that goes from `Outer` through `Inner` to `text`.
let composed_lens = Outer::inner.then(Inner::text);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Side note: Because unlike Haskell, Rust has all the type information during monomorphisation, it can inline all these functions and the extra cost of having 2 lens functions disappears, leaving what you would have written by hand. When you're waiting for Rust's infamously long compilations to finish, know that you're waiting for a potentially significant run-time benefit in exchange.</p>
</blockquote>
<p><code>LensExt</code> contains a few more useful methods for handling things like negating a boolean, or auto-<code>Deref</code>ing a value.</p>
<p>There are also 3 special structs in <code>druid::lens</code>: <code>Constant</code>, <code>Identity</code> and <code>Unit</code>. <code>Constant</code> is a lens that always returns the same value, and always discards any changes, while <code>Identity</code> is a lens that does nothing. You might say &quot;what is the point of a lens that does nothing&quot;, which would be a fair question. Well, there are some places where a lens is required, and having an identity allows the user to say act as if there was no lens. It's also used to begin a composition chain using the combinators like <code>then</code>. <code>Unit</code> is a special case of <code>Constant</code> where the constant in question is <code>()</code>.</p>
<blockquote>
<p>Side note: Because <code>()</code> only has 1 value, it does actually respect mutations. It's just that mutations always result in the same value again (<code>()</code>).</p>
</blockquote>
<h3><a class="header" href="#the-lens-macro" id="the-lens-macro">The <code>lens</code> macro</a></h3>
<p>Finally, there is a macro for constructing lenses on the fly. It allows you to lens into fields of a struct you don't control (so you can't derive <code>Lens</code> for it), it also allows lensing into tuples and tuple structs, and lastly it will create index lenses into slices.</p>
<h3><a class="header" href="#wrapping-up" id="wrapping-up">Wrapping up</a></h3>
<p>Whew, that was quite complicated. Hopefully now you have a solid understanding of the problem that lenses solve, how they solve it, and how to use them effectively. Now you have the ability to relate your application data to widget data, allowing you to use reusable widgets in any configuration you want. If any parts of this page are confusing, please open an issue on the issue tracker or mention it on zulip, and we will see if we can improve the docs (and clear up any misunderstandings you might have).</p>
<h3><a class="header" href="#bonus---mapping-between-complex-structs-automatically" id="bonus---mapping-between-complex-structs-automatically">Bonus - mapping between complex structs automatically</a></h3>
<p>Way back in the first section, we discussed lenses between the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Lens)]
struct Container {
    first_name: Rc&lt;str&gt;,
    last_name: Rc&lt;str&gt;,
    age: u16,
}

struct Name {
    first: Rc&lt;str&gt;,
    last: Rc&lt;str&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>We showed that you can construct a lens from <code>Container</code> to <code>Name</code>, but it was a bit involved and required knowledge of the inner workings of <code>Lens</code>, something you probably don't want to think about. The crate <code>druid-lens-compose</code> is an experiment to allow for building a lens to a struct out of lenses to its fields. It's not well documented, but usage is fairly simple: derive the macro for the inner struct you want to lens to, run <code>cargo doc</code>, and look at the signature of the generated method/build struct. We'd be interested to hear if you found it useful, so please drop by the zulip and let us know!</p>
<h1><a class="header" href="#the-env" id="the-env">The <code>Env</code></a></h1>
<p>The <a href="https://docs.rs/druid/0.7.0/druid/struct.Env.html"><code>Env</code></a> represents the environment; it is intended as a way of managing
and accessing state about your specific application, such as color schemes,
localized strings, and other resources.</p>
<p>The <code>Env</code> is created when the application is launched, and is passed down to all
widgets. The <code>Env</code> may be modified at various points in the tree; values in the
environment can be overridden with other values of the same type, but they can
never be removed. If something exists in the <code>Env</code> at a given level of the tree,
it will exist for everything 'below' that level; that is, for all children of that
widget.</p>
<h2><a class="header" href="#keys-values-and-themes" id="keys-values-and-themes"><code>Key</code>s, <code>Value</code>s, and themes</a></h2>
<p>The most prominent role of <code>Env</code> is to store a set of typed keys and values. The
<code>Env</code> can only store a few types of things; these are represented by the
<a href="https://docs.rs/druid/0.7.0/druid/struct.Value.html"><code>Value</code></a> type, which looks like this:</p>
<pre><code class="language-rust noplaypen">pub enum Value {
    Point(Point),
    Size(Size),
    Rect(Rect),
    Insets(Insets),
    Color(Color),
    Float(f64),
    Bool(bool),
    UnsignedInt(u64),
    String(ArcStr),
    Font(FontDescriptor),
    RoundedRectRadii(RoundedRectRadii),
    Other(Arc&lt;dyn Any + Send + Sync&gt;),
}
</code></pre>
<p>The only way to get an item out of the <code>Env</code> is with a <a href="https://docs.rs/druid/0.7.0/druid/struct.Key.html"><code>Key</code></a>. A <a href="https://docs.rs/druid/0.7.0/druid/struct.Key.html"><code>Key</code></a> is
a combination of a string identifier and a type.</p>
<p>You can think of this as strict types, enforced at runtime. This is less scary
than it sounds, assuming the user follows a few simple guidelines. That said, <strong>It is the
programmer's responsibility to ensure that the environment is used correctly</strong>.
The API is aggressive about checking for misuse, and many methods will panic if
anything is amiss. In practice this should be easy to avoid, by following a few
simple guidelines.</p>
<ol>
<li>
<p><strong><code>Key</code>s should be <code>const</code>s with unique names.</strong> If you need to use a custom
key, you should declare it as a <code>const</code>, and give it a unique name. By
convention, you should namespace your keys using something like <a href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation">reverse-DNS</a>
notation, or even just prefixing them with the name of your app.</p>
<pre><code class="language-rust noplaypen">const BAD_NAME: Key&lt;f64&gt; = Key::new(&quot;height&quot;);
const GOOD_NAME: Key&lt;f64&gt; = Key::new(&quot;com.example.my-app.main-view-height&quot;);
</code></pre>
</li>
<li>
<p><strong><code>Key</code>s must always be set before they are used.</strong> In practice this means
that most keys are set when your application launches, using
<a href="https://docs.rs/druid/0.7.0/druid/struct.AppLauncher.html#method.configure_env"><code>AppLauncher::configure_env</code></a>. Once a key has been added to the <code>Env</code>, it
cannot be deleted, although it can be overwritten.</p>
</li>
<li>
<p><strong>Values can only be overwritten by values of the same type.</strong> If you have a
<code>Key&lt;f64&gt;</code>, assuming that key has already been added to the <code>Env</code>, you cannot
replace it with any other type.</p>
</li>
</ol>
<p>Assuming these rules are followed, <code>Env</code> should just work.</p>
<h3><a class="header" href="#keyorvalue" id="keyorvalue">KeyOrValue</a></h3>
<p>Druid includes a <a href="https://docs.rs/druid/0.7.0/druid/enum.KeyOrValue.html"><code>KeyOrValue</code></a> type that is used for setting certain properties
of widgets. This is a type that can be <em>either</em> a concrete instance of some
type, <em>or</em> a <code>Key</code> that can be used to get that type from the <code>Env</code>.</p>
<pre><code class="language-rust noplaypen">const IMPORTANT_LABEL_COLOR: Key&lt;Color&gt; = Key::new(&quot;org.linebender.example.important-label-color&quot;);
const RED: Color = Color::rgb8(0xFF, 0, 0);

fn make_labels() {
    let with_value = Label::&lt;()&gt;::new(&quot;Warning!&quot;).with_text_color(RED);
    let with_key = Label::&lt;()&gt;::new(&quot;Warning!&quot;).with_text_color(IMPORTANT_LABEL_COLOR);
}
</code></pre>
<h3><a class="header" href="#envscope" id="envscope">EnvScope</a></h3>
<p>You may override values in the environment for a given widget (and all of its
children) by using the <a href="https://docs.rs/druid/0.7.0/druid/widget/struct.EnvScope.html"><code>EnvScope</code></a> widget. This is easiest when combined with
the <a href="https://docs.rs/druid/0.7.0/druid/trait.WidgetExt.html#method.env_scope"><code>env_scope</code></a> method on <a href="https://docs.rs/druid/0.7.0/druid/trait.WidgetExt.html"><code>WidgetExt</code></a>:</p>
<pre><code class="language-rust noplaypen">fn scoped_label() {
    let my_label = Label::&lt;()&gt;::new(&quot;Warning!&quot;).env_scope(|env, _| {
        env.set(druid::theme::TEXT_COLOR, Color::BLACK);
        env.set(druid::theme::TEXT_SIZE_NORMAL, 18.0);
    });
}
</code></pre>
<h2><a class="header" href="#localization" id="localization">Localization</a></h2>
<p><em>localization is currently half-baked</em></p>
<p>The <code>Env</code> contains the localization resources for the current locale. A
<a href="https://docs.rs/druid/0.7.0/druid/struct.LocalizedString.html"><code>LocalizedString</code></a> can be resolved to a given string in the current locale by
calling its <a href="https://docs.rs/druid/0.7.0/druid/struct.LocalizedString.html#method.resolve"><code>resolve</code></a> method.</p>
<p>In general, you should not need to worry about localization directly. See the
<a href="./localization.html">localization</a> chapter for an overview of localization in Druid.</p>
<h1><a class="header" href="#resolution-independence" id="resolution-independence">Resolution independence</a></h1>
<h2><a class="header" href="#what-is-a-pixel-anyway" id="what-is-a-pixel-anyway">What is a pixel anyway?</a></h2>
<p>Pixel is short for <em>picture element</em> and although due to its popularity
it has many meanings depending on context, when talking about pixels in the context of druid
a pixel means always only one thing. It is <strong>the smallest configurable area of color
that the underlying platform allows <code>druid-shell</code> to manipulate</strong>.</p>
<p>The actual physical display might have a different resolution from what the platform knows or uses.
Even if the display pixel resolution matches the platform resolution,
the display itself can control even smaller elements than pixels - the sub-pixels.</p>
<p>The shape of the physical pixel could be complex and definitely varies from display model to model.
However for simplicity you can think of a pixel as a square which you can choose a color for.</p>
<h2><a class="header" href="#display-pixel-density" id="display-pixel-density">Display pixel density</a></h2>
<p>As technology advances the physical size of pixels is getting smaller and smaller.
This allows display manufacturers to put more and more pixels into the same sized screen.
The <strong>pixel densities of displays are increasing</strong>.</p>
<p>There is also an <strong>increasing variety in the pixel density</strong> of the displays used by people.
Some might have a brand new <em>30&quot; 8K UHD</em> (<em>7680px * 4320px</em>) display,
while others might still be rocking their <em>30&quot; HD ready</em> (<em>1366px * 768px</em>) display.
It might even be the same person on the same computer with a multi-display setup.</p>
<h2><a class="header" href="#the-naive-old-school-approach-to-ui" id="the-naive-old-school-approach-to-ui">The naive old school approach to UI</a></h2>
<p>For a very long time UIs have been designed without thinking about pixel density at all.
People tended to have displays with roughly similar pixel densities, so it all kind of
worked most of the time. However <strong>it breaks down horribly</strong> in a modern world.
The <em>200px * 200px</em> UI that looks decent on that <em>HD ready</em> display is barely visible
on the <em>8K UHD</em> display. If you redesign it according to the <em>8K UHD</em> display then
it won't even fit on the <em>HD ready</em> screen.</p>
<h2><a class="header" href="#platform-specific-band-aids" id="platform-specific-band-aids">Platform specific band-aids</a></h2>
<p>Some platforms have mitigations in place where that small <em>200px * 200px</em> UI
will get scaled up by essentially <strong>taking a screenshot of it and enlarging the image.</strong>
This will result in a blurry UI with diagonal and curved lines suffering the most.
There is more hope with fonts where the vector information is still available to the platform,
and instead of scaling up the image the text can be immediately drawn at the larger size.</p>
<h2><a class="header" href="#a-better-solution" id="a-better-solution">A better solution</a></h2>
<p>The application should draw everything it can with <strong>vector graphics</strong>,
and have <strong>very large resolution image</strong> assets available where vectors aren't viable.
Then at runtime the application should identify the display pixel density
and resize everything accordingly. The vector graphics are easy to resize and
the large image assets would be scaled down to the size that makes sense for the specific display.</p>
<h2><a class="header" href="#an-even-better-way" id="an-even-better-way">An even better way</a></h2>
<p>Druid aims to make all of this as <strong>easy and automatic</strong> as possible.
Druid has expressive vector drawing capabilities that you should use whenever possible.
Vector drawing is also used by the widgets that come included with druid.
Handling different pixel densities is done at the <code>druid-shell</code> level already.
In fact pixels mostly don't even enter the conversation at the <code>druid</code> level.
The <code>druid</code> coordinate system is instead measured in <strong>display points</strong> (<strong>dp</strong>),
e.g. you might say a widget has a width of <strong>100dp</strong>.
<em>Display points</em> are conceptually similar to Microsoft's <em>device-independent pixels</em>,
Google's <em>density-independent pixels</em>, Apple's <em>points</em>, and CSS's <em>pixel units</em>.</p>
<p>You <strong>describe the UI using display points and then druid will automatically
translate that into pixels</strong> based on the pixel density of the platform.
Remember there might be multiple displays connected with different pixel densities,
and your application might have multiple windows - with each window on a different display.
It will all just work, because druid will adjust the actual pixel dimensions
based on the display that the window is currently located on.</p>
<h2><a class="header" href="#high-pixel-density-images-with-druid" id="high-pixel-density-images-with-druid">High pixel density images with druid</a></h2>
<p><em>TODO: Write this section after it's more clear how this works and if its even solved.</em></p>
<h1><a class="header" href="#localization-todo" id="localization-todo">Localization (TODO)</a></h1>
<h1><a class="header" href="#command-todo" id="command-todo">Command (TODO)</a></h1>
<h1><a class="header" href="#create-custom-widgets" id="create-custom-widgets">Create custom widgets</a></h1>
<p>The <code>Widget</code> trait is the heart of Druid, and in any serious application you
will eventually need to create and use custom <code>Widget</code>s.</p>
<h2><a class="header" href="#painter-and-controller" id="painter-and-controller"><code>Painter</code> and <code>Controller</code></a></h2>
<p>There are two helper widgets in Druid that let you customize widget behaviour
without needing to implement the full widget trait: <a href="https://docs.rs/druid/0.7.0/druid/widget/struct.Painter.html"><code>Painter</code></a> and
<a href="https://docs.rs/druid/0.7.0/druid/widget/trait.Controller.html"><code>Controller</code></a>.</p>
<h3><a class="header" href="#painter" id="painter">Painter</a></h3>
<p>The <a href="https://docs.rs/druid/0.7.0/druid/widget/struct.Painter.html"><code>Painter</code></a> widget lets you draw arbitrary custom content, but cannot
respond to events or otherwise contain update logic. Its general use is to
either provide a custom background to some other widget, or to implement
something like an icon or another graphical element that will be contained in
some other widget.</p>
<p>For instance, if we had some color data and we wanted to display it as a swatch
with rounded corners, we could use a <code>Painter</code>:</p>
<pre><code class="language-rust noplaypen">fn make_color_swatch() -&gt; Painter&lt;Color&gt; {
    Painter::new(|ctx: &amp;mut PaintCtx, data: &amp;Color, env: &amp;Env| {
        let bounds = ctx.size().to_rect();
        let rounded = bounds.to_rounded_rect(CORNER_RADIUS);
        ctx.fill(rounded, data);
        ctx.stroke(rounded, &amp;env.get(druid::theme::PRIMARY_DARK), STROKE_WIDTH);
    })
}
</code></pre>
<p><code>Painter</code> uses all the space that is available to it; if you want to give it a
set size, you must pass it explicit constraints, such as by wrapping it in a
<a href="https://docs.rs/druid/0.7.0/druid/widget/struct.SizedBox.html"><code>SizedBox</code></a>:</p>
<pre><code class="language-rust noplaypen">fn sized_swatch() -&gt; impl Widget&lt;Color&gt; {
    SizedBox::new(make_color_swatch()).width(20.0).height(20.0)
}
</code></pre>
<p>One other useful thing about <code>Painter</code> is that it can be used as the background
of a <a href="https://docs.rs/druid/0.7.0/druid/widget/struct.Container.html"><code>Container</code></a> widget. If we wanted to have a label that used our swatch
as a background, we could do:</p>
<pre><code class="language-rust noplaypen">fn background_label() -&gt; impl Widget&lt;Color&gt; {
    Label::dynamic(|color: &amp;Color, _| {
        let (r, g, b, _) = color.as_rgba8();
        format!(&quot;#{:X}{:X}{:X}&quot;, r, g, b)
    })
    .background(make_color_swatch())
}
</code></pre>
<p>(This uses the <a href="https://docs.rs/druid/0.7.0/druid/trait.WidgetExt.html#background"><code>background</code></a> method on <a href="https://docs.rs/druid/0.7.0/druid/trait.WidgetExt.html"><code>WidgetExt</code></a> to embed our label in a
container.)</p>
<h3><a class="header" href="#controller" id="controller">Controller</a></h3>
<p>The <a href="https://docs.rs/druid/0.7.0/druid/widget/trait.Controller.html"><code>Controller</code></a> trait is sort of the inverse of <code>Painter</code>; it is a way to
make widgets that handle events, but don't do any layout or drawing. The idea
here is that you can use some <code>Controller</code> type to customize the behaviour of
some set of children.</p>
<p>The <a href="https://docs.rs/druid/0.7.0/druid/widget/trait.Controller.html"><code>Controller</code></a> trait has <code>event</code>, <code>update</code>, and <code>lifecycle</code> methods, just
like <a href="./widget.html"><code>Widget</code></a>; it does not have <code>paint</code> or <code>layout</code> methods. Also unlike
<a href="./widget.html"><code>Widget</code></a>, all of its methods are optional; you can override only the method
that you need.</p>
<p>There's one other difference to the <code>Controller</code> methods; it is explicitly
passed a mutable reference to its child in each method, so that it can modify it
or forward events as needed.</p>
<p>As an arbitrary example, here is how you might use a <code>Controller</code> to make a
textbox fire some action (say doing a search) 300ms after the last keypress:</p>
<pre><code class="language-rust noplaypen">const ACTION: Selector = Selector::new(&quot;hello.textbox-action&quot;);
const DELAY: Duration = Duration::from_millis(300);

struct TextBoxActionController {
    timer: Option&lt;TimerToken&gt;,
}

impl TextBoxActionController {
    pub fn new() -&gt; Self {
        TextBoxActionController { timer: None }
    }
}

impl Controller&lt;String, TextBox&lt;String&gt;&gt; for TextBoxActionController {
    fn event(
        &amp;mut self,
        child: &amp;mut TextBox&lt;String&gt;,
        ctx: &amp;mut EventCtx,
        event: &amp;Event,
        data: &amp;mut String,
        env: &amp;Env,
    ) {
        match event {
            Event::KeyDown(k) if k.key == Key::Enter =&gt; {
                ctx.submit_command(ACTION);
            }
            Event::KeyUp(k) if k.key == Key::Enter =&gt; {
                self.timer = Some(ctx.request_timer(DELAY));
                child.event(ctx, event, data, env);
            }
            Event::Timer(token) if Some(*token) == self.timer =&gt; {
                ctx.submit_command(ACTION);
            }
            _ =&gt; child.event(ctx, event, data, env),
        }
    }
}
</code></pre>
<h2><a class="header" href="#todo" id="todo">todo</a></h2>
<p>v controller, painter</p>
<ul>
<li>how to do layout
<ul>
<li>how constraints work</li>
<li>child widget, set_layout_rect</li>
<li>paint bounds</li>
</ul>
</li>
<li>container widgets</li>
<li>widgetpod &amp; architecture</li>
<li>commands and widgetid</li>
<li>focus / active / hot</li>
<li>request paint &amp; request layout</li>
<li>changing widgets at runtime</li>
</ul>
<h1><a class="header" href="#more-information" id="more-information">More information</a></h1>
<p>If you want more information about Druid this document contains links more tutorials, blogposts and
youtube videos.</p>
<h2><a class="header" href="#related-projects" id="related-projects">Related projects</a></h2>
<p>These three projects provide the basis that Druid works on</p>
<ul>
<li><a href="https://github.com/linebender/piet">Piet</a> An abstraction for 2D graphics.</li>
<li><a href="https://github.com/linebender/kurbo">Kurbo</a> A Rust library for manipulating curves</li>
<li><a href="https://github.com/linebender/skribo">Skribo</a> A Rust library for low-level text layout</li>
</ul>
<h2><a class="header" href="#projects-using-druid" id="projects-using-druid">Projects using Druid</a></h2>
<ul>
<li><a href="https://github.com/tbillington/kondo">Kondo</a> Save disk space by cleaning unneeded files from software projects.</li>
<li><a href="https://github.com/derekdreery/jack-mixer">jack-mixer</a> A jack client that provides mixing, levels and a 3-band eq.</li>
<li><a href="https://github.com/chris-zen/kiro-synth">kiro-synth</a> An in progress modular sound synthesizer.</li>
<li><a href="https://github.com/jpochyla/psst">psst</a> A non-Electron GUI Spotify client.</li>
<li><em>pull requests welcome</em></li>
</ul>
<h2><a class="header" href="#projects-that-work-with-druid-widgets-etc" id="projects-that-work-with-druid-widgets-etc">Projects that work with Druid (widgets etc)</a></h2>
<ul>
<li><em>pull requests welcome</em></li>
</ul>
<h2><a class="header" href="#presentations" id="presentations">Presentations</a></h2>
<p>Some presentations about Druid, its background and related topics have been recorded</p>
<ul>
<li><a href="https://youtu.be/xH2x99FTY4k">Declarative UI patterns in Rust</a> by Raph Levien at the Bay Area Rust Meetup December 3 2019</li>
<li><a href="https://youtu.be/4YTfxresvS8">Data oriented GUI in Rust</a> by Raph Levien at the Bay Area Rust Meetup June 28 2018</li>
</ul>
<h2><a class="header" href="#blog-posts" id="blog-posts">Blog posts</a></h2>
<p>People have been blogging about Druid</p>
<ul>
<li><a href="https://pauljmiller.com/posts/druid-widget-tutorial.html">Building a widget for Druid</a> a blog post by Paul Miller on how to create custom Widgets that explains lots of Druid on the way</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
